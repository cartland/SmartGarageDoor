<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Feather Sessions</title>

  <!-- update the version number as needed -->
  <script defer src="/__/firebase/8.2.9/firebase-app.js"></script>
  <!-- include only the Firebase features as you need -->
  <script defer src="/__/firebase/8.2.9/firebase-firestore.js"></script>
  <!--
      initialize the SDK after all desired features are loaded, set useEmulator to false
      to avoid connecting the SDK to running emulators.
    -->
  <script defer src="/__/firebase/init.js?useEmulator=true"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.4/dist/Chart.min.js"></script>

  <style>
    #chartContainer {
      padding-left: 0;
      padding-right: 0;
      margin-left: auto;
      margin-right: auto;
    }
  </style>
</head>

<body>

  <div id="chartContainer" class="chart-container" style="position: relative; height:40vh; width:80vw">
    <canvas id="lineChart"></canvas>
  </div>

  <script>

    // Top level variable for debugging.
    var scatterChart;

    const COLOR_OPACITY = 'AA'; // Slightly transparent.
    const COLORS = [
      '#E74C3C' + COLOR_OPACITY,
      '#9B59B6' + COLOR_OPACITY,
      '#3498DB' + COLOR_OPACITY,
      '#1ABC9C' + COLOR_OPACITY,
      '#F4D03F' + COLOR_OPACITY,
      '#E67E22' + COLOR_OPACITY,
    ];

    /**
     * Formats date and time. Time must be provided in local timezone.
     * YYYY-MM-DD hh:mm
     */
    function myDateFormat(date, seconds) {
      var DD = date.getDay();
      var MM = date.getMonth() + 1;
      var YYYY = date.getFullYear();
      var hh = date.getHours();
      var min = date.getMinutes();
      var ss = date.getSeconds();
      if (DD < 10) {
        DD = '0' + DD;
      }
      if (MM < 10) {
        MM = '0' + MM;
      }
      if (hh < 10) {
        hh = '0' + hh;
      }
      if (min < 10) {
        min = '0' + min;
      }
      if (ss < 10) {
        ss = '0' + ss;
      }
      if (seconds) {
        return YYYY + '-' + MM + '-' + DD + ' ' + hh + ':' + min + ':' + ss;
      }
      return YYYY + '-' + MM + '-' + DD + ' ' + hh + ':' + min;
    }

    /**
     * Convert UTC milliseconds to local timezone Date object.
     */
    function utcSecondsToLocalDateFormat(milliseconds, showSeconds) {
      const x = new Date(0);
      x.setUTCMilliseconds(milliseconds + 60 * x.getTimezoneOffset());
      return myDateFormat(x, showSeconds);
    }

    function getCurrentUtcTimeMillis() {
      return new Date().getTime();
    }

    document.addEventListener('DOMContentLoaded', function () {
      // // ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥
      // // The Firebase SDK is initialized and available here!
      // // ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥ðŸ”¥

      var ctx = document.getElementById('lineChart').getContext('2d');
      scatterChart = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: []
        },
        options: {
          title: {
            text: 'Battery Voltage Over Time by Session',
            display: true,
            fontSize: 24,
          },
          scales: {
            xAxes: [{
              scaleLabel: {
                display: true,
                labelString: 'Time',
                fontSize: 24,
              },
              type: 'linear',
              position: 'bottom',
              ticks: {
                callback: (value, index, values) => {
                  const milliseconds = value;
                  const showSeconds = false;
                  return utcSecondsToLocalDateFormat(milliseconds, showSeconds);
                }
              }
            }],
            yAxes: [{
              scaleLabel: {
                display: true,
                labelString: 'Voltage',
                fontSize: 24,
              },
            }]
          },
          tooltips: {
            titleAlign: 'center',
            callbacks: {
              label: function (tooltipItem, data) {
                return data.datasets[tooltipItem.datasetIndex].label;
              },
              title: function (tooltipItem, data) {
                const item = tooltipItem[0];
                return [
                  item.value + ' V',
                ];
              },
              footer: function (tooltipItem, data) {
                const item = tooltipItem[0];
                const showSeconds = true;
                return [
                  utcSecondsToLocalDateFormat(item.xLabel, showSeconds),
                ];
              },
              labelColor: function (tooltipItem, data) {
                const color = COLORS[tooltipItem.datasetIndex % COLORS.length];
                return {
                  borderColor: color,
                  backgroundColor: color,
                };
              },
            }
          },
          onClick: (arr, elements) => {
            console.log(arr, elements);
          },
        }
      });

      const nowMillis = getCurrentUtcTimeMillis();
      let start = new Date(0);
      const MAX_WINDOW_RANGE_MILLIS = 1000 * 60 * 60 * 72; // 72 hours.
      start.setUTCMilliseconds(nowMillis - MAX_WINDOW_RANGE_MILLIS);

      firebase.firestore().collection("updateAll")
        .where('FIRESTORE_databaseTimestamp', '>', start)
        .orderBy("FIRESTORE_databaseTimestamp", "asc")
        .onSnapshot((doc) => {
          const observations = {};
          for (let lineNumber = 0; lineNumber < doc.docs.length; lineNumber++) {
            const line = doc.docs[lineNumber];
            const data = line.data();
            // Check to make sure all of the relevant data fields exist.
            if (!('session' in data)
              || !('FIRESTORE_databaseTimestamp' in data)
              || !('seconds' in data['FIRESTORE_databaseTimestamp'])
              || !('queryParams' in data)
              || !('batteryVoltage' in data['queryParams'])
            ) {
              // Skip data that is missing necessary fields.
              continue;
            }
            const session = data['session'];
            if (!(session in observations)) {
              observations[session] = [];
            }
            const seconds = parseInt(data['FIRESTORE_databaseTimestamp']['seconds']);
            const voltage = parseFloat(data['queryParams']['batteryVoltage'])
            observations[session].push({
              'utcSeconds': seconds,
              'batteryVoltage': voltage,
            });
          }
          for (const session of Object.keys(observations)) {
            observations[session].sort((a, b) => {
              return a['utcSeconds'] - b['utcSeconds'];
            });
          }
          let minUtcSeconds = undefined;
          let maxUtcSeconds = undefined;
          scatterChart.config.data.datasets = [];
          for (const session of Object.keys(observations)) {
            const sessionObservations = observations[session];
            const numberOfPointsInSession = sessionObservations.length;
            if (numberOfPointsInSession < 2) {
              console.log('Skipping session', session,
                ' because there are fewer than 2 data points');
              continue;
            }
            const firstObservation = sessionObservations[0];
            const firstUtcSeconds = firstObservation['utcSeconds'];
            const lastObservation = sessionObservations[sessionObservations.length - 1];
            const lastUtcSeconds = lastObservation['utcSeconds'];
            if (lastUtcSeconds - firstUtcSeconds < 60 * 10) {
              console.log('Skipping session', session,
                ' because first and last are less than 10 minutes apart', firstUtcSeconds, lastUtcSeconds);
              continue;
            }
            const lineData = [];
            for (let observationIndex = 0; observationIndex < numberOfPointsInSession; observationIndex++) {
              const utcSeconds = sessionObservations[observationIndex]['utcSeconds'];
              if (typeof minUtcSeconds === 'undefined') {
                minUtcSeconds = utcSeconds;
              }
              if (typeof maxUtcSeconds === 'undefined') {
                maxUtcSeconds = utcSeconds;
              }
              if (utcSeconds < minUtcSeconds) {
                minUtcSeconds = utcSeconds;
              }
              if (utcSeconds > maxUtcSeconds) {
                maxUtcSeconds = utcSeconds;
              }
              const x = new Date(0);
              x.setUTCSeconds(utcSeconds);
              const y = sessionObservations[observationIndex]['batteryVoltage'];
              if (y < 2) {
                continue; // Ignore test data.
              }
              const point = {
                x: x,
                y: y,
              };
              lineData.push(point);
            }
            const color = COLORS[scatterChart.config.data.datasets.length % COLORS.length];
            scatterChart.config.data.datasets.push({
              label: session.substring(0, 5),
              data: lineData,
              borderColor: color,
              backgroundColor: '#00000000',
            });
          }
          console.log(scatterChart.config.data.datasets);

          // The step size for time looks better if the number fits nicely into a clock.
          // Good examples: 15 minutes, 30 minutes, 1 hour
          const minStepSizeMillis = 60 * 60 * 1000; // 1 hour.
          const utcSecondsRange = maxUtcSeconds - minUtcSeconds;
          // Only start scaling up if the range is 10X longer than the minStep.
          const scale = Math.max(
            1, // Make sure the the scale is an integer 1 or larger.
            Math.floor((utcSecondsRange * 1000 / minStepSizeMillis) / (10 / 2))
          );
          // As we cover large time scales, we want the chart to step over bigger numbers.
          const newStepSize = scale * minStepSizeMillis;
          scatterChart.options.scales.xAxes[0].ticks.stepSize = newStepSize;
          scatterChart.update();
        });
    });
  </script>
</body>

</html>